# 创建二叉搜索树
`二叉搜索树`也叫`二叉查找树`或`二叉排序`.

二叉搜索树特点:
```txt
1. 如果左子树非空, 则左子树所有节点 都要小于 根节点
2. 如果右子树非空, 则右子树所有节点 都要大于 根节点
3. 其中左右子树也分别是 二叉搜索树.
    左子树 < 根 < 右子树  (此时要按照这个大小排序输出的话, 就是中序遍历)

    注意: 二叉搜索树中 **不允许出现重复节点**
```

代码实现:
- 核心理念: 只要涉及二叉树, 必然用到`递归`!!!!!!!!!!

核心代码:

```c
// ---------- 用数组内的元素创建二叉搜索树 -------------
struct BSTree_node * create_BStree(unsigned int arr[], int n)
{
    struct BSTree_node *tree = NULL;
    int i;

    for(i = 0; i < n; i++){
        tree = insert_bstree(tree, arr[i]);       // 往二叉树中插入新节点(按照大小排序插入子树)
    }
    return tree;
}

struct BSTree_node * insert_bstree(struct BSTree_node *T, unsigned int elem)
{
    // 如果传进来的是空树, 则: 创建根节点, 然后左右子树设置为空, 再将将它添作为新的树返回
    if(T == NULL){
        T = (struct BSTree_node *)malloc(sizeof(struct BSTree_node));       // 先开辟空间
        T->elem = elem;
        T->ltree = T->rtree = NULL;
    }
    else if(elem < T->elem){        // 假如传进来的不是空树, 则比较一下elem与当前(子树)根节点的大小, 从而确定把它放到左子树还是右子树位置
        T->ltree = insert_bstree(T->ltree, elem);      // 利用递归的思想: 此时 ltree 必然是空树, 会直接走上面的if分支
    }
    else if(elem > T->elem){        // 假如传进来的不是空树, 则比较一下elem与当前(子树)根节点的大小, 从而确定把它放到左子树还是右子树位置
        T->rtree = insert_bstree(T->rtree, elem);      // 利用递归的思想: 此时 rtree 必然是空树, 会直接走上面的if分支
    }
    else{                           // 此时 elem == T->elem
        printf("Inserting repeat node is forbidden!\n");
        exit(0);
    }
    return T;
}
```

---

# 查找 & 添加二叉搜索树
核心代码 -- 查找:
```c
// --- 非递归写法 ---
int search_bstree(struct BSTree_node *tree, unsigned int num)
{
    struct BSTree_node *p = tree;       // 指向当前遍历的节点

    while(p != NULL){
        if(num == p->elem){             // 找到想要的元素
            return 1;
        }
        else if(num < p->elem){         // 目标位于左子树
            p = p->ltree;               // p更新到左子树的根节点
        }
        else{
            p = p->rtree;               // 目标位于右子树
        }
    }
    return 0;
}

// ---- 递归写法 -----
int search_bstree(struct BSTree_node *tree, unsigned int num)
{
    if(tree != NULL){
        if(num == tree->elem){             // 找到想要的元素
            return 1;
        }
        else if(num < tree->elem){         // 目标位于左子树
            return search_bstree(tree->ltree, num);
        }
        else{
            return search_bstree(tree->rtree, num);
        }
    }
    return 0;
}
```

核心代码 -- 插入新节点
```c
struct BSTree_node * insert_bstree(struct BSTree_node *T, unsigned int elem)
{
    // 如果传进来的是空树, 则: 创建根节点, 然后左右子树设置为空, 再将将它添作为新的树返回
    if(T == NULL){
        T = (struct BSTree_node *)malloc(sizeof(struct BSTree_node));       // 先开辟空间
        T->elem = elem;
        T->ltree = T->rtree = NULL;
    }
    else if(elem < T->elem){        // 假如传进来的不是空树, 则比较一下elem与当前(子树)根节点的大小, 从而确定把它放到左子树还是右子树位置
        T->ltree = insert_bstree(T->ltree, elem);      // 利用递归的思想: 此时 ltree 必然是空树, 会直接走上面的if分支
    }
    else if(elem > T->elem){        // 假如传进来的不是空树, 则比较一下elem与当前(子树)根节点的大小, 从而确定把它放到左子树还是右子树位置
        T->rtree = insert_bstree(T->rtree, elem);      // 利用递归的思想: 此时 rtree 必然是空树, 会直接走上面的if分支
    }
    else{                           // 此时 elem == T->elem
        printf("Inserting repeat node is forbidden!\n");
        exit(0);
    }
    return T;
}
```


---

# 删除二叉搜索树


---

# 平衡二叉搜索树原理

