# 数据结构 -- 查找/搜索
查找可以分为`有序查找`和`无序查找`.


## 线性结构
线性结构指的是在内存中连续存储的数据结构, 比如数组, 堆和栈.
- 线性结构中的有序查找最简单的就是暴力枚举, 遍历所有的元素, 然后依次比较. 
  - 这种方式通常需要进行两次比较: `判断当前访问是否越界` + `判断当前元素是否为目标元素`.

代码实现 -- `sqsearch.c`
```c
#include <stdio.h>

#define SIZE 100

int SqSearch(int array[], int n, int x);

int main(void)
{
    int n;
    int i;
    int arr[SIZE];
    int x;

    printf("Please enter the number of your data: \n");
    scanf("%d", &n);
    printf("Please enter the element of your data: \n");
    for(i = 0; i < n; i++){
        scanf("%d", &arr[i]);
    }

    printf("Please enter the element you want to search:");
    scanf("%d", &x);

    i = SqSearch(arr, n, x);

    if(i == -1){
        printf("Cannot find the element in your data.\n");
    }
    else{
        printf("The element you want to search is in %d position!\n", i);
    }

    return 0;
}

int SqSearch(int array[], int n, int x)
{
    int i;
    for (i = 0; i < n; i++){
        if(array[i] == x){
            return i;
        }
    }
    return -1;
}
```


- 针对这种查找模式的一个优化方案是`哨兵`思想. 
```txt
在数组的最后增加一个元素, 增加的元素是我们希望查找的目标target, 并且将它称为"哨兵".
    此时, 如果原来的数组中存在target, 那么增加"哨兵"后的数组就会有两个target. 显然, 此时一定能找到一次 target.

这种方法带来的优势是: 
    每次循环中减少了一次判断, 一定程度上降低了开销.
```

代码实现 -- `sqsearch_guard.c`
```c
#include <stdio.h>

#define SIZE 100

int SqSearch_Guard(int array[], int n, int x);

int main(void)
{
    int n;
    int i;
    int arr[SIZE];
    int x;

    printf("Please enter the number of your data: \n");
    scanf("%d", &n);
    printf("Please enter the element of your data: \n");
    for(i = 0; i < n; i++){
        scanf("%d", &arr[i]);
    }

    printf("Please enter the element you want to search:");
    scanf("%d", &x);

    i = SqSearch_Guard(arr, n, x);

    if(i == n){
        printf("Cannot find the element in your data.\n");
    }
    else{
        printf("The element you want to search is in %d position!\n", i);
    }

    return 0;
}

int SqSearch_Guard(int array[], int n, int x)
{
    int i;
    array[n] = x;       // 数组末尾增加哨兵

    for (i = 0; array[i] != x; i++);        // 这时候不再需要判断是否越界
    return i;
}
```





