# 单链表原理及基本操作实现
回顾一下栈和队列, 他们的实现都是`基于数组`和循环得到的, 由于`数组在内存中是连续排布`的, 故`栈 和 队列 在内存中也是连续排布`的.

链表与数组不同, 链表是`离散排布`的, 他的每个元素都是一个独立的对象, 他们通过`指针`相连.
- 劣势:
  - 访问元素很麻烦
    - 由于**不是连续分布**的, 所以链表`不支持随机访问`(只能从头开始遍历才能找到某个指定的节点).
- 优势:
  - 具有优秀的数据重排能力
    - 也由于链表**不是连续分布**, 插入/删除元素的时候无需挪动其他元素, 直接将新节点加入/删除链中即可, 故链表的`插入和删除`操作比数组`高效`.

--- 

链表的组成:
- 节点
- 头指针 head
  - 通过头指针可以找到链表的第一个元素
- 尾指针 tail
  - 尾指针永远指向 NULL

---

对于节点(`node`):
- 本质上是一个`结构体`, 包含两个部分:
  - 数据域
    - 用于存储数据
  - 指针域
    - 必须是一个结构体指针, 结构体类型就是节点的类型
    - 用于指向下一个节点的起始地址
    - 最后一个节点的指针域指向空(NULL 或 nullptr)


---

链表基本操作:
- 创建链表(create linklist)
```txt
  1. 创建新节点
    假设已经存在链表的 head 和 tail 指针 (若没有, 则手动创建一下, 并都初始化为 NULL).
        1) 开辟一段内存空间作为新节点, 并划分出数据域以及指针域, 然后返回当前内存空间的起始地址;
            - C 语言使用 malloc 函数, 但是注意 malloc 函数返回的是 void* 类型, 需要**强制转换为节点类型**.
            - C++ 语言直接使用 new 即可
        2) 填充数据域, 指针域设置为 NULL
  2. 将节点接入链表
    - 可简单分为 头插法 和 尾插法.
        - 对于 尾插法: 除了head固定指向链表第一个节点之外, 需要定义一个 tail 指针, 让它永远指向最后一个节点
            1) 先检查头指针, 将某个指针指向新增节点(以下情况只会发生一种, 用if-else): 
                - 如果新增的节点是链表的第一个节点, 则直接让 head 指向加入的加点; 
                - 如果新增的节点不是链表的第一个节点, 则先将尾节点的next指针指向新增节点.
            2) 更新尾结点: 由于是尾插法, 新加入的节点一定是链表最末尾的节点, 故尾结点**最终**一定指向新加入的节点.
```

- 插入节点图解
```txt
输入: 
  1. 插入链表的哪个位置
  2. 插入的节点 (或者提供节点的数据, 此时需要在函数内完成节点的创建)

操作:
  在指定位置插入新节点:
      如果插入的位置**是头结点**:
          1. 直接将新增节点的 next指针 指向 head 所指向的位置 ==> 效果就是 新增节点 位于链表的头部
          2. 将head指向的位置改为 新增节点 ==> 坐实新增节点的地位
      如果插入的位置**不是头结点**
          1. 遍历链表找到 pos位置 的前一个节点(前趋点)
              建立一个 pre指针 指向前趋点节点
          2. 将 pre指针 指向新增节点, 然后将 新增节点 的 next指针 指向原来pos位置的节点.
              - 为了防止 指向pos位置的节点指针丢失, 需要先将这个指针先存入 "新插入节点的指针域(将它的next设置为指向原来pos位置的节点)" 
              - 然后再将pre的 next指针 指向新增节点
          3. (不能忘记!!!!) 检查插入位置是否为末尾位置 ==> 坐实新增节点的地位
```
![](单链表原理及基本操作实现_images/图解_链表中插入节点.png)

- 删除节点
```txt
与 "插入节点" 一样, 删除节点也需要 "前趋点" pre.

如果删除的**是头结点**
    1. 把 pre 设置为 head 
    2. 将 head 存放的地址更新为 原来head的指针域里存放的地址 (head直接挪到下一个位置)
    3. 释放被删除的节点空间, 防止内存泄露
如果删除的**不是头结点**
    1. 遍历链表, 找到前趋点(index 为 pos - 1 的位置)
    2. 将准备删除的节点指针 p 赋值为 pre->next (也就是 p 指向了 pos 位置)
    3. 将 pre指针 指向 pos 的下一个节点 (此时链表将绕开 pos 节点)
    4. 检查 pos 指向的节点是否为 "尾结点", 特征是 p->next 为 NULL
    5. 释放被删除的节点空间, 防止内存泄露
```
![](单链表原理及基本操作实现_images/图解_链表中删除节点.png)

- 遍历链表
- 查找节点
- 销毁链表




