# 单链表原理及基本操作实现
回顾一下栈和队列, 他们的实现都是`基于数组`和循环得到的, 由于`数组在内存中是连续排布`的, 故`栈 和 队列 在内存中也是连续排布`的.

链表与数组不同, 链表是`离散排布`的, 他的每个元素都是一个独立的对象, 他们通过`指针`相连.
- 劣势:
  - 访问元素很麻烦
    - 由于**不是连续分布**的, 所以链表`不支持随机访问`(只能从头开始遍历才能找到某个指定的节点).
- 优势:
  - 具有优秀的数据重排能力
    - 也由于链表**不是连续分布**, 插入/删除元素的时候无需挪动其他元素, 直接将新节点加入/删除链中即可, 故链表的`插入和删除`操作比数组`高效`.

--- 

链表的组成:
- 节点
- 头指针 head
  - 通过头指针可以找到链表的第一个元素
- 尾指针 tail
  - 尾指针永远指向 NULL

---

对于节点(`node`):
- 本质上是一个`结构体`, 包含两个部分:
  - 数据域
    - 用于存储数据
  - 指针域
    - 必须是一个结构体指针, 结构体类型就是节点的类型
    - 用于指向下一个节点的起始地址
    - 最后一个节点的指针域指向空(NULL 或 nullptr)


---

链表基本操作:
- 创建链表(create linklist)
```txt
  1. 创建新节点
    假设已经存在链表的 head 和 tail 指针 (若没有, 则手动创建一下, 并都初始化为 NULL).
        1) 开辟一段内存空间作为新节点, 并划分出数据域以及指针域, 然后返回当前内存空间的起始地址;
            - C 语言使用 malloc 函数, 但是注意 malloc 函数返回的是 void* 类型, 需要**强制转换为节点类型**.
            - C++ 语言直接使用 new 即可
        2) 填充数据域, 指针域设置为 NULL
  2. 将新节点链接到已有链表中
        1) 如果 head 为 NULL, 表明当前链表一个节点都没有, 此时将 head = p;
        2) 如果 head 不为 NULL, 表明当前链表至少有一个节点, 此时将 tail->next = p;   (尾插法: 将新来的节点全部塞到链表末尾)
```

- 插入节点



- 遍历链表
- 删除节点
- 查找节点
- 销毁链表




