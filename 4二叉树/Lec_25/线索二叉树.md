# 线索二叉树
它是从数据的存储方式为出发点细分出来的数据结构.

## 背景
```txt
常见的二叉树 -- 从根节点一直延伸到叶子节点的路径.
         A
       /    \
      B      C
     / \    / 
    D   E  F 
            \ 
             G

    构建二叉树时使用的存储结构:
        struct BinTree_node
        {
            int data;
            BinTree_node *left_tree;
            BinTree_node *right_tree;
        }

    在这种存储结构下, 二叉树无法快速找到某个节点的前驱和后继节点    ==> 不利于查找/遍历
        因为节点的结构体中只有 data, left_tree, right_tree 三个成员变量.
        这时候我们只知道 "去向", 无法根据当前节点知道 "来向"  
```
- 这种二叉树, 由于存储时每个节点都是在内存里离散存放的, 它不连续, 使用的是指针联系起来(类似链表), 因此也叫`非线性结构`.
  - 线性结构: 数组, 栈, 队列

使用`线性结构进行存储`的二叉树, 叫做`线索二叉树`.

--- 

## 线索二叉树的构建方式
- 这种二叉树会根据不同的`遍历`方式, 有不同的存储结果:
  - 先序遍历: `ABDECFG`
  - 中序遍历: `DBEAFGC`
  - 后序遍历: `DEBGFCA`
- **确定排序结果(遍历方式)之后**, 直接将排序后的节点直接存入 **数组/栈/队列** 中, 之后就可以根据已知的排序方式或叫线索化方式快速找到前驱和后继节点了.
  - 例如: `DBEAFGC` 中, `B` 的前驱是 `D`, 后继是 `E`
    - 故: 哪怕是询问同一个节点, 使用不同的线索化方式(遍历方式), 将得到不一样的前趋点和后继点.

再次强调一下, 线索化二叉树的目的:
- 能在存储的数据中, 迅速找到当前节点的`前驱节点`和`后继节点`.

---

## 线索化方式的对比与选择

### 先序遍历的前趋点和后继点
```txt
         A
       /    \
      B      C
     / \    / 
    D   E  F 
            \ 
             G
    先序遍历的结果是: `ABDECFG`

对于前趋点(一共有 4种 情况):
    - 对于节点B来说:
        有父节点A, B是A的左子树, 因此B的前趋点是A
    - 对于节点G来说:
        有父节点F, 其左"兄弟"是空, G是右子树, 此时F是G的前趋点
    - 对于节点C来说:
        C节点是右子树, 其左"兄弟"是 B(不为空), 此时C的前趋点是 "左兄弟子树B" 进行先序遍历的最后一个节点    ==>  E
            也就是单独对B的子树进行先序遍历, 得到的遍历结果是 BDE, 故E是C的前趋点
    - 对于A来说:
        A是根节点, 没有父节点, 也没有左兄弟子树, 因此A的前趋点是空 ==> 无前趋点

对于后继点:
    - 对于B节点:
        有左子树, 则左子树节点就是它的后继点  ==> D
    - 对于F节点:
        无左子树, 后继点就是其右子树 ==> G
```
- 从上面分析可以知道, 采用先序遍历的线索化时, 寻找前趋点有**4种**情况, 寻找后继点有**2种**情况.

### 中序遍历的前趋点和后继点
```txt
         A
       /    \
      B      C
     / \    / 
    D   E  F 
            \ 
             G
    中序遍历的结果是: `DBEAFGC`

对于前趋点(一共有 2种 情况):
    - 对于A节点:
        中序遍历左子树后的最后一个节点就是它的前趋点 ==> E
            中序遍历左子树 B 的结果是: BDE, E是B的后继点 
            也可以简单理解为中序遍历后的 "左子树最右下" 的节点
    - 对于 D/E/G: 
        都无左子树, 稍后讨论(当前先看看哪种遍历方式更简单)

对于后继结点:
    - 对于A节点:
        其中序遍历右子树后, 访问的第一个节点就是它的后继点 ==> F
            A 的右子树是 C, C 的中序遍历结果是 FGC, 故F是C的后继点
            也可以简单理解为中序遍历后的 "右子树最左下" 的节点
    - 对于 C/E/G/D:
        都无右子树, 稍后分析(当前先看看哪种遍历方式更简单)
```
- 中序遍历的线索化方式, 寻找前趋点有**2种**情况, 寻找后继点有**2种**情况.


### 后序遍历的前趋点和后继点
```txt
         A
       /    \
      B      C
     / \    / 
    D   E  F 
            \ 
             G
    后序遍历的结果是: `DEBGFCA`

对于前趋点(一共有 2种 情况):
    - 有右子树, 如 A
        有右子树, 则右子树的根节点就是它的前趋点 ==> C
    - 无右子树: 如 D/E/C/G
        暂不详细讨论(当前先看看哪种遍历方式更简单)
    
    - 无右子树, 但有左子树, 如 C
        则左子树节点就是它的前趋点 ==> F

对于后继结点:
    - 对于C节点
        A是它的父节点, C是A的右子树, 则此时 A 是 C 的后继节点
            B, E节点也有相同特征.
    - 对于F节点
        C是F的父节点, F是C的左子树, 并且C的"右兄弟子树"为空, 则此时父节点C是它的后继节点 ==> C
    - 对于节点B:
        存在B的父节点(A点), 且C是B的"右兄弟子树"后序遍历后的第一个节点, 则此时B节点的后继点是 C
    - 如果是根节点A, 则没有后继节点
```


对比上面三种遍历的情况, `中序遍历`的前趋点和后继点的寻找方式最简单, 因此我们选择`中序遍历`的方式进行线索化. 



