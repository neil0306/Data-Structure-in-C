# 哈希表(Hash Table)
哈希表也称为"散列表".

线性查找, 树表查找(包括二叉搜索树/平衡二叉搜索树)都是基于`比较`进行查找的, 每次比较都会有点慢, 故希望找到一种`不基于比较的查找方式` --> 哈希表.
- 哈希表是通过`计算(或映射)进行查找`的.
  - key(待查找值) 与 存储位置 之间存在映射关系.
  - 计算的方式称为`哈希函数 H()`.
    - H(key) ==> 存储位置 ==> 得到查找结果

在使用哈希函数进行计算时, 很可能出现如下情况:
```txt
H(key1) == H(key2)    // 这种情况称为 "冲突", 同时 key1 和 key2 称为 "同义词"
```
- 冲突不可避免, 只能尽可能减少冲突, 一般在使用哈希表时要考虑如下两种操作:
  - 预防措施: 选取适当的哈希函数来减少冲突
  - 解决措施: 冲突发生时, 解决冲突


## 哈希函数的选取
1. 直接地址法
2. 平方取中法
3. 叠加法
4. 保留余数法
   - 最成熟的方法(本笔记主要介绍这种方法)
5. 随机函数法


### 保留余数法 (质数除余法)
```txt
假设有一个Hash空间, 最多可以存放 m个元素, 选取一个 "不大于m" 的 "最大质数p", 做如下操作:
    key % p = 余数
        此时这个余数就是key在哈希表中的存储位置.

此时预防冲突的措施是:
    哈希填充因子为 70% ~ 80%
        
    哈希填充因子的计算公式为: alpha = n/m   (n 为哈希表中填充的元素个数, m为哈希表总的空间大小)

举例:
如果我们有12个元素要存放, 此时根据哈希填充因子的经验值80%, 我们可以知道应该创建能存放15个元素的空间, 
此时, 为了防止冲突, 也是根据选择质数规则得到 p = 13 (此时算出来的余数范围是 0~12)
    那么, 元素5的存放地址就是 5%13 = 5, 因此该元素存放的地址就是5了.
```

----
## 解决哈希冲突的方式
1. 开放地址法
    ```txt
    包含:
        - 线性探测法 (最简单的方法, 本笔记主要介绍这种方法)
        - 二次探测法
        - 随机探测法
    ```
2. 链地址法
3. 建立公共溢出区



### 开放地址法
线性探测法 -- 最简单的方法 
```txt
如果key1 和 key2 冲突, 即 H(key1) == H(key2), 线性探测法的解决方法是:

    ( H(key1) + offset ) % m          // 注意不再是除以质数p, 而是除以整个哈希空间的大小m

    其中, offset 也叫增量步长, 取值范围是 1, 2, 3, ..., (m-1)
```
- 优点是总能找到一个地方放入冲突的元素
  - 因为哈希填充因子的规定, 总是存在空余的位置
- 缺点是可能存在堆积
  - 某些位置堆放很紧凑, 其他位置可能很稀疏; 如果存放很紧凑, 那么在寻找位置的时候就需要计算多次才能找到空的地方, 也就是遇到连续冲突.


二次探测法:
```txt
在线性探测法的基础上, 将 offset 的取值范围改成:
    1^2, (-1)^2, 2^2, (-2)^2, 3^2, (-3)^2 ..., (m-1)^2, (-m+1)^2

    正负号分别表示 往右走 和 往左走
```
- 优点是元素堆积(冲突堆积)的可能性变低


## 举例 -- 哈希表存放元素过程
使用的哈希函数是`质数取余法`, 解决冲突的方法是`线性探测法`
![](查找_哈希表_images/哈希表存储过程_图示.png)








